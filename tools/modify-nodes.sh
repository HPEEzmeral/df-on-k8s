#!/usr/bin/env bash
# return codes
NO=0
YES=1
INFO=0
WARN=-1
ERROR=1

NODE_INFO="node.info"
NAME_KEY="name"
# labels
USE_NODE_KEY="hpe.com/usenode"
EXCLUDE_NODE="hpe.com/excludenode"
COMPUTE_KEY="hpe.com/compute"
STORAGE_KEY="hpe.com/storage"
NODE_STATUS_KEY="hpe.com/status"
# annotations
TOPOLOGY_KEY="hpe.com/nodetopology"
RACK_KEY="hpe.com/rack"
FULLDISKLIST_KEY="hpe.com/fulldisklist"
SSDLIST_KEY="hpe.com/ssdlist"
HDDLIST_KEY="hpe.com/hddlist"
NVMELIST_KEY="hpe.com/nvmelist"
BOOTSTRAP_VERSION_KEY="hpe.com/bootstrapversion"
NODE_ID_KEY="hpe.com/physicalnodeid"
VALIDATION_STATUS_KEY="hpe.com/validationstatus"

# misc
SEP=","
TRUE="true"
FALSE="false"

usage()
{
    echo "usage: modify-nodes.sh [[[-f file location ] | [-h]]"
    echo "modify-nodes.sh is used to edit labels, annotations, and taints on your Kubernetes nodes."
    echo "modify-nodes.sh will use the information in a node.info file generated by the get-node-info.sh."
}

script_tests() {
  error=$NO
  array[0]='test' || error=$YES
  if [ ! $error -eq 0 ]; then
    echo 'ERROR: arrays not supported in this version of bash.'
    exit 1
  fi
  command -v jq > /dev/null
  if [ ! $? -eq 0 ]; then
    echo "ERROR: jq is not installed. Please install jq via 'brew install jq' or 'yum install jq'"
    exit 1
  fi
  command -v kubectl > /dev/null
  if [ ! $? -eq 0 ]; then
    echo "ERROR: kubectl is not installed. Please install kubectl."
    exit 1
  fi
}

get_taints() {
    local taints=$()
    TAINT_ARRAY=( $taints )
}

get_tainted_nodes() {
    local nodes=$(cat $NODE_INFO | jq .taints[] | tr '\n' ' ' | tr -d '\"')
    TAINTED_NODES_ARRAY=( $nodes )
}

get_node_array() {
  local nodes=$(cat $NODE_INFO | jq .nodes[].name | tr '\n' ' ' | tr -d '\"')
  NODE_ARRAY=( $nodes )
}

get_excluded_nodes() {
  local excludednodes=$(cat $NODE_INFO | jq .excludednodes[] | tr '\n' ' ' | tr -d '\"')
  EXCLUDED_ARRAY=( $excludednodes )
}

delete_label() {
  local nodename=$1
  local key=$2
  echo "Calling 'kubectl label node $nodename $key-'...."
  kubectl label node $nodename $key-
}

delete_annotation() {
  local nodename=$1
  local key=$2
  echo "Calling 'kubectl annotate node $nodename $key-'...."
  kubectl annotate node $nodename $key-
}

delete_taint() {
  local nodename=$1
  local key=$2
  echo "Calling 'kubectl taint node $nodename $key-'...."
  kubectl taint node $nodename $key-
}

taint_node() {
  local nodename=$1
  local key=$2
  local value=$3
  local kind=$4
  echo "Calling 'kubectl annotate node $nodename $key=$value --overwrite'...."
  kubectl taint node $nodename $key=$value':'$kind --overwrite
}

annotate_node() {
  local nodename=$1
  local key=$2
  local value=$3
  echo "Calling 'kubectl annotate node $nodename $key=$value --overwrite'...."
  kubectl annotate node $nodename $key=$value --overwrite
}

label_node() {
  local nodename=$1
  local key=$2
  local value=$3
  echo "Calling 'kubectl label node $nodename $key=$value --overwrite'...."
  kubectl label node $nodename $key=$value --overwrite
}

get_value() {
  local nodecount=$1
  local key=$2
  local arg1="--arg valkey \"$key\""
  local param="'.nodes[$nodecount] | .[$valkey]'"
  local node=$(jq --arg valkey "$key" .nodes[$nodecount] $NODE_INFO)
  local rawval=$(echo $node | jq --arg valkey "$key" '.[$valkey]')
  local value=$(echo $rawval | tr -d '\"')
  echo $value
}

update_node() {
  local nodename=$1
  local nodecount=$2
  local usenode="true"
  local compute=$(get_value $nodecount $COMPUTE_KEY)
  local storage=$(get_value $nodecount $STORAGE_KEY)
  local rack=$(get_value $nodecount $RACK_KEY)
  local topology=$(get_value $nodecount $TOPOLOGY_KEY)
  local fulldisklist=$(get_value $nodecount $FULLDISKLIST_KEY)
  local ssdlist=$(get_value $nodecount $SSDLIST_KEY)
  local hddlist=$(get_value $nodecount $HDDLIST_KEY)
  local nvmelist=$(get_value $nodecount $NVMELIST_KEY)
  label_node $nodename $USE_NODE_KEY $usenode
  label_node $nodename $COMPUTE_KEY $compute
  label_node $nodename $STORAGE_KEY $storage
  annotate_node $nodename $RACK_KEY $rack
  annotate_node $nodename $TOPOLOGY_KEY $topology
  annotate_node $nodename $FULLDISKLIST_KEY $fulldisklist
  annotate_node $nodename $SSDLIST_KEY $ssdlist
  annotate_node $nodename $HDDLIST_KEY $hddlist
  annotate_node $nodename $NVMELIST_KEY $nvmelist
}

taint_nodes() {
  get_taints
  local count=0
  while [ "x${TAINT_ARRAY[$count]}" != "x" ]
  do
    local taintname=${TAINT_ARRAY[$count]}
    get_tainted_nodes
    local nodecount=0
    while [ "x${TAINTED_NODES_ARRAY[$nodecount]}" != "x" ]
    do
      local nodename=${TAINTED_NODES_ARRAY[$nodecount]}
      kubectl taint node $nodename $taintname-
      nodecount=$(( $nodecount + 1 ))
    done
    count=$(( $count + 1 ))
  done
}

update_nodes() {
  get_node_array
  local count=0
  while [ "x${NODE_ARRAY[$count]}" != "x" ]
  do
    local nodename=${NODE_ARRAY[$count]}
    update_node $nodename $count
    count=$(( $count + 1 ))
  done

}

exclude_nodes() {
  get_excluded_nodes
  local count=0
  while [ "x${EXCLUDED_ARRAY[$count]}" != "x" ]
  do
    local nodename=${EXCLUDED_ARRAY[$count]}
    # exclude node
    delete_label $nodename $USE_NODE_KEY
    count=$(( $count + 1 ))
  done

}

while [ "$1" != "" ]; do
    case $1 in
        -f | --file )           shift
                                NODE_INFO=$1
                                ;;
        -h | --help )           usage
                                exit
                                ;;
        * )                     usage
                                exit 1
    esac
    shift
done

script_tests
update_nodes
exclude_nodes
#taint_nodes
